play.server.http.idleTimeout = infinite

## Internationalisation
play.i18n {
  langs = [ "en" ]
}

## Play HTTP settings
play.http {
  secret.key = ""

  parser.maxDiskBuffer=20MB
  parser.maxMemoryBuffer=20MB

  forwarded.trustedProxies=["192.168.1.0/24", "::1", "127.0.0.1"]

  session = {
    # The cookie name
    cookieName = "PLAY_SESSION"

    # Whether the secure attribute of the cookie should be set to true
    secure = true

    # The max age to set on the cookie.
    # If null, the cookie expires when the user closes their browser.
    # An important thing to note, this only sets when the browser will discard the cookie.
    #maxAge = null

    # Whether the HTTP only attribute of the cookie should be set to true
    httpOnly = true

    # The value of the SameSite attribute of the cookie. Set to null for no SameSite attribute.
    sameSite = "lax"

    # The domain to set on the session cookie
    # If null, does not set a domain on the session cookie.
    #domain = null

    # The session path
    # Must start with /.
    path = ${play.http.context}

    jwt {
      # The JWT signature algorithm to use on the session cookie
      # uses 'alg' https://tools.ietf.org/html/rfc7515#section-4.1.1
      signatureAlgorithm = "HS256"

      # The time after which the session is automatically invalidated.
      # Use 'exp' https://tools.ietf.org/html/rfc7519#section-4.1.4
      expiresAfter = ${play.http.session.maxAge}

      # The amount of clock skew to accept between servers when performing date checks
      # If you have NTP or roughtime synchronizing between servers, you can enhance
      # security by tightening this value.
      clockSkew = 5 minutes

      # The claim key under which all user data is stored in the JWT.
      dataClaim = "data"
    }
  }
}

## Netty Provider
play.server.netty {
  # Whether the Netty wire should be logged
  #log.wire = true

  # If you run Play on Linux, you can use Netty's native socket transport
  # for higher performance with less garbage.
  #transport = "native"
}

## Modules
play.modules {
  #disabled += ""

  enabled += "play.api.db.DBModule"
  enabled += "play.api.db.HikariCPModule"

  enabled += "play.filters.csrf.CSRFModule"
  enabled += "play.filters.cors.CORSModule"
  enabled += "play.filters.headers.SecurityHeadersModule"
  enabled += "play.filters.hosts.AllowedHostsModule"
  enabled += "play.filters.gzip.GzipFilterModule"

}

## Filters
play.filters {

  #Redirect Https filter configuration
  https {
    #any request that is not secure is redirected
    #redirectEnabled = true

    #redirectStatusCode = 308
  }

  enabled = [
    play.filters.cors.CORSFilter,
    #play.filters.csrf.CSRFFilter,
    play.filters.headers.SecurityHeadersFilter,
    play.filters.hosts.AllowedHostsFilter
  ]

  #play.filters.disabled += "play.filters.headers.SecurityHeadersFilter"

  ## CORS filter configuration
  cors {
    # Filter paths by a whitelist of path prefixes
    #pathPrefixes = ["/some/path", ...]

    # The allowed origins. If null, all origins are allowed.
    #allowedOrigins = ["http://www.example.com"

    # The allowed HTTP methods. If null, all methods are allowed
    #allowedHttpMethods = ["GET", "POST"]

		pathPrefixes = ["/"]
		allowedOrigins = null
    #allowedOrigins = ["http://localhost:8080"]
		allowedHttpMethods = ["POST", "GET", "OPTIONS", "DELETE", "PUT"]
		#allowedHttpHeaders = null
		allowedHttpHeaders = ["x-requested-with", "Content-Type", "origin", "authorization", "accept", "client-security-token", "x-forwarded-for", "access-control-allow-origin"]
		#preflightMaxAge = 1000 days
		#serveForbiddenOrigins = "*"
    serveForbiddenOrigins = false
  }

  ## CSRF Filter
  csrf {
    # Sets the cookie to be sent only over HTTPS
    #cookie.secure = true

    # How much of the body should be buffered when looking for the token in the request body
    body.bufferSize = ${play.http.parser.maxMemoryBuffer}

    # Bypass the CSRF check if this origin is trusted by the CORS filter
    bypassCorsTrustedOrigins = true

    header {
      # The name of the header to accept CSRF tokens from.
      #name = "Csrf-Token"

      # Defines headers that must be present to perform the CSRF check. If any of these headers are present, the CSRF
      # check will be performed.
      #
      # By default, we only perform the CSRF check if there are Cookies or an Authorization header.
      # Generally, CSRF attacks use a user's browser to execute requests on the client's behalf. If the user does not
      # have an active session, there is no danger of this happening.
      #
      # Setting this to null or an empty object will protect all requests.
      #protectHeaders {
      #  Cookie = "*"
      #  Authorization = "*"
      #}
      protectHeaders = null

      # Defines headers that can be used to bypass the CSRF check if any are present. A value of "*" simply
      # checks for the presence of the header. A string value checks for a match on that string.
      bypassHeaders {
        X-Requested-With = "*"
        Csrf-Token = "nocheck"
      }
    }

    # Defaults to CSRFErrorHandler in the root package.
    #errorHandler = MyCSRFErrorHandler
  }

  ## Security headers filter configuration
  headers {
    # The X-Frame-Options header. If null, the header is not set.
    #frameOptions = "DENY"

    # The X-XSS-Protection header. If null, the header is not set.
    #xssProtection = "1; mode=block"

    # The X-Content-Type-Options header. If null, the header is not set.
    #contentTypeOptions = "nosniff"

    # The X-Permitted-Cross-Domain-Policies header. If null, the header is not set.
    #permittedCrossDomainPolicies = "master-only"

    # The Content-Security-Policy header. If null, the header is not set.
    #contentSecurityPolicy = "default-src 'self'"
    contentSecurityPolicy = null

    # The Referrer-Policy header. If null, the header is not set.
    #referrerPolicy = "origin-when-cross-origin, strict-origin-when-cross-origin"

    # If true, allow an action to use .withHeaders to replace one or more of the above headers
#    allowActionSpecificHeaders = false
  }

  ## Allowed hosts filter configuration
  hosts {
    # Allow requests to example.com, its subdomains, and localhost:9000.
    #allowed = [".example.com", "localhost:9000"]
    allowed = ["."]
  }

  gzip {
    bufferSize = 8k
    #compressionLevel = 9
  }
}

# Number of database connections
# See https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing
fixedConnectionPool = 9

# Set Hikari to fixed size
play.db {
  prototype {
    hikaricp.minimumIdle = ${fixedConnectionPool}
    hikaricp.maximumPoolSize = ${fixedConnectionPool}
  }
}

# Job queue sized to HikariCP connection pool
database.dispatcher {
  executor = "thread-pool-executor"
  throughput = 1
  thread-pool-executor {
    fixed-pool-size = ${fixedConnectionPool}
  }
}

# Lombok configuration
lombok.addNullAnnotations = true

play.modules.enabled += "play.modules.swagger.SwaggerModule"
#swagger.filter = "SwaggerConfigurationFilter"

#swagger configuration
api.version="1.0"
swagger.api.basepath="/v1/api"
swagger.routes= "routes"


include "secure.conf"
include "twitter.conf"

include "db_config_mysql.conf"
#use evolution create db tables
#include "db_evolutions_mysql.conf"

